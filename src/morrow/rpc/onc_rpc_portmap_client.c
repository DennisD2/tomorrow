/*
 * x.c
 *
 *  Created on: 30.03.2018
 *      Author: dennis
 */

#define PMAP_PORT 111
#define PMAP_PROGRAM 100000
#define PMAP_VERSION 2

#include <stdio.h>
#include <rpc/rpc.h>	/* always need this */
#include <rpc/pmap_prot.h>

#include "portmap.h"	    /* generated by rpcgen */
#include "vxi11.h"	    /* generated by rpcgen */

#define VXI_ROGRAM 0x0607AF /*100024*/
#define VXI_VERSION 1
#define VXI_TCP 6

static CLIENT *client;

/** timeout value in [ms] */
static int VXI11_DEFAULT_TIMEOUT = 10000;


int initializeClient(char *host) {
	char *protocol = "tcp";

	CLIENT *cl = clnt_create(host, PMAP_PROGRAM, PMAP_V2, protocol);
	if (cl == (CLIENT *) NULL) {
		clnt_pcreateerror(host);
		exit(1);
	}
	client = cl;
	printf("Portmapper client created.\n");
}

void listServices() {
	PMAP2DUMPres *maplist = pmap2_dump_2(NULL, client);

	struct pmap2_mapping_list *l = maplist->list;
	do {
		struct pmap2_mapping pm = l->map;
		printf("prog: %d, vers: %d, prot: %d, port: %d\n", pm.prog, pm.vers, pm.prot, pm.port);
		l = l->next;
	} while (l != NULL) ;
}

int getVXIPort() {
	pmap2_mapping m;
	m.prog = VXI_ROGRAM;
	m.vers = VXI_VERSION;
	m.prot = VXI_TCP;
	int *vxiPort = pmap2_getport_2(&m, client);
	if (*vxiPort != 0) {
		printf("VXI port found: %d\n", *vxiPort);
	} else {
		printf("No VXI port found\n");

	}
	return vxiPort;
}

void getVersion(int id, unsigned short* major, unsigned short* minor) {
    unsigned short response;
    unsigned short rpe;
    unsigned int ret;

    unsigned short cmd = 0xc8ff; // abort normal operation
    //ret = ivxiws(id, cmd, &response, &rpe);
    //printf("ret: %u, response=%x, rpe=%u\n", ret, response, rpe);
    if (response != 0xfffe) {
        printf("Error1: %x\n", response);
        return;
    }
    printf("Abort Normal Operation: OK\n");

    cmd = 0xfcff; // begin normal operation
    //ret = ivxiws(id, cmd, &response, &rpe);
    printf("ret: %u, response=%x, rpe=%u\n", ret, response, rpe);
    /* See page 16 what to check for success. I do not understand what is said there. */
    printf("Begin Normal Operation: OK\n");

    cmd = 0x7c00; // get version
    //ret = ivxiws(id, cmd, &response, &rpe);
    //printf("ret: %u, response=%x, rpe=%u\n", ret, response, rpe);
    *major = response >> 4;
    *minor = response & 0xf;
    //printf("Version: %d.%d\n", *major, *minor );
    printf("Get Version: OK\n");
}


int main222(int argc, char **argv) {
	char *host = "192.168.178.78"; //"127.0.0.1";
	char *protocol = "tcp";

	char *device = "vxi,126";
	if (argc==2) {
		device = argv[1];
	}

	initializeClient(host);

	//listServices();

	int *vxiPort = getVXIPort();

	CLIENT *cl = clnt_create(host, VXI_ROGRAM, VXI_VERSION, protocol);
	if (cl == (CLIENT *) NULL) {
		clnt_pcreateerror(host);
		exit(1);
	}
	client = cl;
	printf("VXI client OK\n");

	printf("Creating link for device '%s'\n", device);
	Create_LinkParms args;
	args.clientId = 12346;
	args.device = device;
	args.lockDevice = 0;
	args.lock_timeout = VXI11_DEFAULT_TIMEOUT;
	Create_LinkResp *resp = create_link_1(&args, cl);
	if (resp == NULL) {
		printf("Link creation failed\n");
	}
	if (resp->lid == 0) {
		printf("Link creation failed, LID=0\n");
		printf("error: %u\n", resp->error);
		exit(1);
	}
	printf("Link creation OK\n");
	printf("LID: %u\n", resp->lid);
	//printf("error: %u\n", resp->error);
	printf("maxRecvSize: %u\n", resp->maxRecvSize);

	Device_Link theLID = resp->lid;

	// iscpi,126 -> Error 20, Access LED leuchtet am 9054 auf
	// scpi,126 -> Error 3
	// iscpi,125 --> Error 3
	// vxi,125 -> Error 3
	// vxi,126 -> OK !!!, aber Access LED leuchtet am 9054 nicht auf

	// error codes p.197
	// 3 = I_ERR_BADADDR Bad address The device/interface address passed to iopen does not exist. Verify that the interface name is the one assigned with Connection Expert.
	// 20 = I_ERR_NODEV Device is not active or available. Tried to specify a device session when it is not active, available, or does not exist.

	/*printf("Calling DoCmd...\n");
	Device_DocmdParms cargs;
	cargs.cmd = 0xc8ff;
	cargs.data_in.data_in_val = NULL;
	cargs.data_in.data_in_len = 0;
	cargs.flags = 0;
	cargs.io_timeout = VXI11_DEFAULT_TIMEOUT;
	cargs.lid = theLID;
	cargs.lock_timeout = VXI11_DEFAULT_TIMEOUT;
	cargs.network_order = 1;
	Device_DocmdResp *cresp = device_docmd_1(&cargs, cl);
	if (cresp == NULL) {
		printf("device_write failed\n");
		exit(1);
	}
	if (cresp->error != 0) {
		printf("error: %u\n", cresp->error);
	}
	// I_ERR_NOTSUPP Operation not supported Operation not supported on this implementation.
	*/

	printf("Calling device...\n");
	unsigned char command[2];
	command[0] = 0xc8;
	command[1] = 0xff;
	Device_WriteParms wargs;
	wargs.data.data_len = 2;
	wargs.data.data_val = command;
	wargs.flags = 8;
	wargs.io_timeout = VXI11_DEFAULT_TIMEOUT;
	wargs.lid = theLID;
	wargs.lock_timeout = VXI11_DEFAULT_TIMEOUT;
	Device_WriteResp *wresp = device_write_1(&wargs, cl);
	if (wresp == NULL) {
		printf("device_write failed\n");
		exit(1);
	}
	if (wresp->error != 0) {
		printf("error: %u\n", wresp->error);
		//exit(1);
	}
	printf("Calling device...\n");
	command[0] = 0xff;
	command[1] = 0xc8;
	wargs.data.data_len = 2;
	wargs.data.data_val = command;
	wargs.flags = 8;
	wargs.io_timeout = VXI11_DEFAULT_TIMEOUT;
	wargs.lid = theLID;
	wargs.lock_timeout = VXI11_DEFAULT_TIMEOUT;
	wresp = device_write_1(&wargs, cl);
	if (wresp == NULL) {
		printf("device_write failed\n");
		exit(1);
	}
	if (wresp->error != 0) {
		printf("error: %u\n", wresp->error);
		exit(1);
	}

/*
	printf("Calling device...\n");
	command[0] = 0xfc;
	command[1] = 0xff;
	wargs.data.data_len = 2;
	wargs.data.data_val = command;
	wargs.flags = 0;
	wargs.io_timeout = VXI11_DEFAULT_TIMEOUT;
	wargs.lid = theLID;
	wargs.lock_timeout = VXI11_DEFAULT_TIMEOUT;
	wresp = device_write_1(&wargs, cl);
	if (wresp == NULL) {
		printf("device_write failed\n");
		exit(1);
	}
	if (wresp->error != 0) {
		printf("error: %u\n", wresp->error);
	}

	printf("Calling device...\n");
	command[0] = 0x7c;
	command[1] = 0x00;
	wargs.data.data_len = 2;
	wargs.data.data_val = command;
	wargs.flags = 0;
	wargs.io_timeout = VXI11_DEFAULT_TIMEOUT;
	wargs.lid = theLID;
	wargs.lock_timeout = VXI11_DEFAULT_TIMEOUT;
	wresp = device_write_1(&wargs, cl);
	if (wresp == NULL) {
		printf("device_write failed\n");
		exit(1);
	}
	if (wresp->error != 0) {
		printf("error: %u\n", wresp->error);
	}
*/
	// Error 15: I_ERR_TIMEOUT
	printf("Calling device OK\n");
	printf("error: %u\n", wresp->error);
	printf("data size: %u\n", wresp->size);

	return 0;
}
